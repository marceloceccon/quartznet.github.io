(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{445:function(e,t,o){"use strict";o.r(t);var r=o(26),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[e._v('Quartz is architected in modular way, and therefore to get it running, several components need to be "snapped" together.\nFortunately, some helpers exist for making this happen.')]),e._v(" "),o("p",[e._v("The major components that need to be configured before Quartz can do its work are:")]),e._v(" "),o("ul",[o("li",[e._v("ThreadPool")]),e._v(" "),o("li",[e._v("JobStore")]),e._v(" "),o("li",[e._v("DataSources (if necessary)")]),e._v(" "),o("li",[e._v("The Scheduler itself")])]),e._v(" "),o("p",[e._v("The ThreadPool provides a set of Threads for Quartz to use when executing Jobs.\nThe more threads in the pool, the greater number of Jobs that can run concurrently.\nHowever, too many threads may bog-down your system.\nMost Quartz users find that 5 or so threads are plenty- because they have fewer than 100 jobs at any given time,\nthe jobs are not generally scheduled to run at the same time, and the jobs are short-lived (complete quickly).\nOther users find that they need 10, 15, 50 or even 100 threads - because they have tens-of-thousands\nof triggers with various schedules - which end up having an average of between 10 and 100 jobs trying to\nexecute at any given moment. Finding the right size for your scheduler's pool is completely dependent on\nwhat you're using the scheduler for. There are no real rules, other than to keep the number of threads as\nsmall as possible (for the sake of your machine's resources) - but make sure you have enough for your Jobs to fire on time.\nNote that if a trigger's time to fire arrives, and there isn't an available thread,\nQuartz will block (pause) until a thread comes available, then the Job will execute -\nsome number of milliseconds later than it should have. This may even cause the tread to misfire - if\nthere is no available thread for the duration of the scheduler's configured \"misfire threshold\".")]),e._v(" "),o("p",[e._v("A IThreadPool interface is defined in the Quartz.Spi namespace, and you can create a IThreadPool implementation in any way you like.\nQuartz ships with a simple (but very satisfactory) thread pool named Quartz.Simpl.SimpleThreadPool.\nThis IThreadPool implementation simply maintains a fixed set of threads in its pool - never grows, never shrinks.\nBut it is otherwise quite robust and is very well tested - as nearly everyone using Quartz uses this pool.")]),e._v(" "),o("p",[e._v("JobStores and DataSrouces were discussed in Lesson 9 of this tutorial. Worth noting here, is the fact that all JobStores\nimplement the IJobStore interface - and that if one of the bundled JobStores does not fit your needs, then you can make your own.")]),e._v(" "),o("p",[e._v("Finally, you need to create your Scheduler instance. The Scheduler itself needs to be given a name and handed\ninstances of a JobStore and ThreadPool.")]),e._v(" "),o("h2",{attrs:{id:"stdschedulerfactory"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#stdschedulerfactory"}},[e._v("#")]),e._v(" StdSchedulerFactory")]),e._v(" "),o("p",[e._v("StdSchedulerFactory is an implementation of the ISchedulerFactory interface.\nIt uses a set of properties (NameValueCollection) to create and initialize a Quartz Scheduler.\nThe properties are generally stored in and loaded from a file, but can also be created by your program and handed directly to the factory.\nSimply calling getScheduler() on the factory will produce the scheduler, initialize it (and its ThreadPool, JobStore and DataSources),\nand return a handle to its public interface.")]),e._v(" "),o("p",[e._v('There are some sample configurations (including descriptions of the properties) in the "docs/config" directory of the Quartz distribution.\nYou can find complete documentation in the "Configuration" manual under the "Reference" section of the Quartz documentation.')]),e._v(" "),o("h2",{attrs:{id:"directschedulerfactory"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#directschedulerfactory"}},[e._v("#")]),e._v(" DirectSchedulerFactory")]),e._v(" "),o("p",[e._v("DirectSchedulerFactory is another SchedulerFactory implementation. It is useful to those wishing to create their Scheduler\ninstance in a more programatic way. Its use is generally discouraged for the following reasons: (1) it\nrequires the user to have a greater understanding of what they're doing, and (2) it does not allow for declaritive\nconfiguration - or in other words, you end up hard-coding all of the scheduler's settings.")]),e._v(" "),o("h2",{attrs:{id:"logging"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#logging"}},[e._v("#")]),e._v(" Logging")]),e._v(" "),o("p",[e._v("Quartz.NET uses the "),o("a",{attrs:{href:"http://netcommon.sourceforge.net/"}},[e._v("Common.Logging framework")]),e._v(' for all of its logging needs.\nQuartz does not produce much logging information - generally just some information during initialization, and\nthen only messages about serious problems while Jobs are executing. In order to "tune" the logging settings\n(such as the amount of output, and where the output goes), you need to understand the Commmon.Logging framework,\nwhich is beyond the scope of this document, please refer to '),o("a",{attrs:{href:"http://netcommon.sourceforge.net/documentation.html"}},[e._v("Common.Logging Documentation")]),e._v(".")])])}),[],!1,null,null,null);t.default=n.exports}}]);